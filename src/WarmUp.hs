
-- Here are five different implementations of the factorial [1].
-- In this code I am going to study each of them.


-- [1] Ruehr. Fritz  The Evolution of a Haskell Programmer,
-- Willamette University, http://www.willamette.edu/~fruehr/haskell/evolution.html

-- Tested with GHC 8.10.1 and QuickCheck 2.14.2.


import Numeric.Natural
import Test.QuickCheck(arbitrary, Arbitrary, arbitrarySizedNatural,
                     shrink, shrinkIntegral, quickCheck)

instance Arbitrary Natural where
    arbitrary = arbitrarySizedNatural
    shrink = shrinkIntegral

-- | The function to test fac1, fac2, fac3, fac4, fac5
fac :: Natural -> Natural
fac n = product [1..n ]

-- The names next to the following functions are the programmer level according to [1].

fac1 :: Natural -> Natural
fac1 n = if n == 0      -- Freshman Haskell programmer
           then 1
           else n * fac1 (n-1)

fac2 :: Natural -> Natural
fac2 = (\(n) ->         -- Sophomore Haskell programmer, at MIT
        (if ((==) n 0)
            then 1
            else ((*) n (fac2 ((-) n 1)))))

fac3 :: Natural -> Natural
fac3 0 = 1      -- Another junior Haskell programmer
fac3 n = n * fac3 (n-1)

fac4 :: Natural -> Natural
fac4 = foldr (*) 1 . enumFromTo 1       -- “Points-free” Haskell programmer

fac5 :: Natural -> Natural
fac5 n = snd (until ((>n) . fst) (\(i,m) -> (i+1, i*m)) (1,1))      -- Iterative one-liner Haskell programmer

------------------------------------------------------------------------------
-- Properties

-- | This function takes a list with the above functions
-- | and a natural that is generated by QuickCheck, and then
-- | compares the result of the functions with fac, to know if they are correct
prop_fac :: [Natural -> Natural] -> Natural -> Bool
prop_fac [] _ = True
prop_fac (x:xs) num = x num == fac num && prop_fac xs num

------------------------------------------------------------------------------
-- Main
main :: IO ()
main = quickCheck $ prop_fac [fac1,fac2,fac3,fac4,fac5]

